class_name ProcGen extends Node

signal finished

const Context = preload("generator/context.gd")

#@export_tool_button("Generate") var _generate_callback = generate
@export var map_size: Vector2i = Vector2i(300, 300):
	set(value): map_size = Vector2i.ONE.max(value)

## Custom seed to apply to the generator. Leave empty to generate a new seed
## on each run.
@export var seed: String

@export_group("Zones", "zone")

## The maximum ratio when splitting zones.
## (i.e. when splitting a zone into 2 subzones,
## dictates how larger zone A can be over zone B) [br]
## [code]0.5[/code] -> The split will always be in the middle [br]
## [code]0.7[/code] -> The split will be between 30%~70% of the zone's length
@export_range(0.5, 0.99) var zone_split_max_ratio: float = 0.5

## The chance that a zone uses the same split orientation as its parent. [br]
## For example, given zone A that was split [i]horizontally[/i] 
## to produce zone B and C: [br]
## [code]0.0[/code] -> Zone B will be split [i]horizontally[/i] like its parent
## zone A. [br]
## [code]0.1[/code] -> Zone B will be split [i]vertically[/i], opposite to its
## parent. [br]
## [code]0.5[/code] -> 50% chance of being split either [i]horizontally[/i] or
## [i]vertically[/i]
@export_range(0.0, 1.0, 0.01) var zone_orientation_alternate_chance: float = 0.5

@export_group("Rooms", "room")

## The amount of rooms that will be generated.
@export_range(1, 1, 1, "or_greater") var room_amount: int

## The maximum ratio of a room, basically how rectangular it is. [br]
## [code]0.5[/code] -> Rooms are always squares [br]
## [code]0.7[/code] -> Width will be between 30%~70% bigger/smaller than height
@export_range(0.5, 0.99) var room_max_ratio: float

## The minimum coverage ratio of a room. Coverage is how much of the zone the
## room occupies.
@export_range(0.01, 0.99, 0.01) var room_min_coverage_ratio: float:
	set(value): room_min_coverage_ratio = min(value, room_max_coverage_ratio)

## The maximum coverage ratio of a room. Coverage is how much of the zone the
## room occupies.
@export_range(0.01, 0.99, 0.01) var room_max_coverage_ratio: float:
	set(value): room_max_coverage_ratio = max(value, room_min_coverage_ratio)

## How centered is a room inside its zone. [br]
## [code]0.0[/code] -> Rooms can be anywhere inside their zone. [br]
## [code]1.0[/code] -> Rooms are always at the center of their zone.
@export_range(0.0, 1.0, 0.01) var room_center_ratio: float

@export_group("Corridors", "corridor")

## The minimum ratio, of overlap between 2 zones' edges to be considered 
## adjacent. Adjacent zones are zones whose rooms can be connected with 
## corridors [br]
## [code]0.3[/code] -> if at least 30% of a zone's edge touches another
@export_range(0.0, 1.0, 0.01) var corridor_edge_overlap_min_ratio: float

## The chance that the path generated by corridors may connect to a room it
## was already connected to, making a looping path. [br]
## [code]0.0[/code] -> corridors will never loop back. [br]
## [code]1.0[/code] -> corridors will always loop back.
@export_range(0.0, 1.0, 0.01) var corridor_cycle_chance: float

@export_group("Automaton", "automaton")

## The number of iteration to run the Cellular Automata. More iterations will
## lead to more "eroded" looking terrain. [code]0[/code] to disable it.
@export_range(0, 1, 1, "or_greater") var automaton_iterations: int

## The minimum number of neighboring cells set to full for the current cell to
## also be full. (i.e. given a cell at a given position, 
## how many surrounding cells needs to be full for it to be full as well)
@export_range(0, 8) var automaton_cell_min_neighbors: int:
	set(value): automaton_cell_min_neighbors = min(value, automaton_cell_max_neighbors)

## The maximum number of neighboring cells set to full for the current cell to
## also be full. (i.e. given a cell at a given position, 
## how many surrounding cells needs to be full for it to be empty)
@export_range(0, 8) var automaton_cell_max_neighbors: int:
	set(value): automaton_cell_max_neighbors = max(value, automaton_cell_min_neighbors)

## The chance that a cell will be full at the initial state of the automaton.
## [code]0.0[/code] -> every cell is empty. [br]
## [code]1.0[/code] -> every cell is full.
@export_range(0.0, 1.0, 0.01) var automaton_noise_rate: float

## If set, will fill up isolated holes in the grid at the end of the all
## automaton iterations.
@export var automaton_flood_fill: bool

var _generator := preload("generator/generator.gd").new()

func _ready() -> void:
	_generator.finished.connect(finished.emit)
	generate()

func generate():
	var ctx := Context.new()
	
	ctx.map_size = map_size

	ctx.zone_split_max_ratio = zone_split_max_ratio
	ctx.zone_orientation_alternate_chance = zone_orientation_alternate_chance

	ctx.room_amount = room_amount
	ctx.room_max_ratio = room_max_ratio
	ctx.room_min_coverage_ratio = room_min_coverage_ratio
	ctx.room_max_coverage_ratio = room_max_coverage_ratio
	ctx.room_center_ratio = room_center_ratio

	ctx.corridor_edge_overlap_min_ratio = corridor_edge_overlap_min_ratio
	ctx.corridor_cycle_chance = corridor_cycle_chance

	ctx.automaton_iterations = automaton_iterations
	ctx.automaton_cell_min_neighbors = automaton_cell_min_neighbors
	ctx.automaton_cell_max_neighbors = automaton_cell_max_neighbors
	ctx.automaton_noise_rate = automaton_noise_rate
	ctx.automaton_flood_fill = automaton_flood_fill
	
	if seed.is_empty():
		ctx.rng.randomize()
	else:
		ctx.rng.seed = seed.hash()
	
	_generator.generate(ctx)
